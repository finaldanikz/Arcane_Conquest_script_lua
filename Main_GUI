local existingGui = game.Players.LocalPlayer.PlayerGui:FindFirstChild("PersistentGUI")
if existingGui then
    existingGui:Destroy()
end

-- Initialize variables at the top
local player = game.Players.LocalPlayer
local gui = nil
local mainFrame = nil
local closeButton = nil
local saveFilePath = "settings.txt"
local tpDelay = 2.5  -- Default teleport delay of 2.5 seconds
local enemyRange = 5  -- Default range from enemy
local tweenSpeed = 1  -- Add missing tweenSpeed variable
local autoAbilityLoop = nil  -- Add missing variable
local autoAbilityActive = false  -- Add missing variable

-- Forward declare functions that are used before their definitions
local createGui
local makeDraggable
local loadSettings
local saveSettings

-- Utility functions
local function loadSettings()
    local success, data = pcall(function()
        return game:GetService("HttpService"):JSONDecode(readfile(saveFilePath))
    end)
    if success then
        return data
    else
        return {}
    end
end

local function saveSettings(settings)
    pcall(function()
        writefile(saveFilePath, game:GetService("HttpService"):JSONEncode(settings))
    end)
end

makeDraggable = function(object)
    local UserInputService = game:GetService("UserInputService")
    local dragging
    local dragInput
    local dragStart
    local startPos

    local function update(input)
        local delta = input.Position - dragStart
        object.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end

    object.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = object.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    object.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            update(input)
        end
    end)
end

-- Find Nearest NPC Function
local function findNearestNPC()
    local nearestNPC = nil
    local nearestDistance = math.huge
    
    local Character = player.Character
    if not Character or not Character:FindFirstChild("HumanoidRootPart") then return end
    
    local enemies = workspace:FindFirstChild("enemies")
    if not enemies then return end
    
    for _, child in ipairs(enemies:GetChildren()) do
        if child:FindFirstChild("enemiesFolder") then
            for _, npc in ipairs(child.enemiesFolder:GetChildren()) do
                if npc:FindFirstChild("HumanoidRootPart") and npc:FindFirstChild("Humanoid") and npc.Humanoid.Health > 0 then
                    local distance = (Character.HumanoidRootPart.Position - npc.HumanoidRootPart.Position).Magnitude
                    if distance < nearestDistance then
                        nearestDistance = distance
                        nearestNPC = npc
                    end
                end
            end
        end
    end
    return nearestNPC
end

-- Auto Hit functionality
local autoHitActive = false
local autoHitLoop = coroutine.create(function()
    while true do
        if autoHitActive then
            pcall(function()
                local args = {
                    [1] = true
                }
                game:GetService("ReplicatedStorage").Click:FireServer(unpack(args))
            end)
        end
        task.wait(0.3)
    end
end)

local function toggleAutoHit(isEnabled)
    autoHitActive = isEnabled
    if isEnabled and coroutine.status(autoHitLoop) == "suspended" then
        coroutine.resume(autoHitLoop)
    end
end

-- Auto Ability functionality
local function toggleAutoAbility(isEnabled)
    autoAbilityActive = isEnabled
    if isEnabled then
        if not autoAbilityLoop then
            autoAbilityLoop = spawn(function()
                while autoAbilityActive and wait(0.5) do
                    pcall(function()
                        local character = game.Players.LocalPlayer.Character
                        if character and character:FindFirstChild("HumanoidRootPart") then
                            local lookVector = character.HumanoidRootPart.CFrame.LookVector
                            
                            -- Fire Spell1 in player's look direction
                            local spell1Args = {
                                [1] = "Spell1",
                                [2] = character.HumanoidRootPart.Position,
                                [3] = lookVector,
                                [4] = 0
                            }
                            game:GetService("ReplicatedStorage").Spell:FireServer(unpack(spell1Args))
                            
                            wait(0.1)
                            
                            -- Fire Spell2 in player's look direction
                            local spell2Args = {
                                [1] = "Spell2",
                                [2] = character.HumanoidRootPart.Position,
                                [3] = lookVector,
                                [4] = 0
                            }
                            game:GetService("ReplicatedStorage").Spell:FireServer(unpack(spell2Args))
                        end
                    end)
                end
            end)
        end
    else
        autoAbilityActive = false
        if autoAbilityLoop then
            autoAbilityLoop = nil
        end
    end
end


local function findNearestEnemy()
    local nearestEnemy = nil
    local nearestDistance = math.huge
    
    local character = game.Players.LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    
    local enemiesFolder = workspace:FindFirstChild("Enemies")
    if not enemiesFolder then return end
    
    for _, enemy in ipairs(enemiesFolder:GetChildren()) do
        if enemy:FindFirstChild("HumanoidRootPart") and 
           enemy:FindFirstChild("Humanoid") and 
           enemy.Humanoid.Health > 0 then
            
            local distance = (character.HumanoidRootPart.Position - enemy.HumanoidRootPart.Position).Magnitude
            if distance < nearestDistance then
                nearestDistance = distance
                nearestEnemy = enemy
            end
        end
    end
    
    return nearestEnemy
end

-- teleport functionality
local TweenService = game:GetService("TweenService")
local mobTeleportActive = false
local teleportLoop = nil

local function tweenToEnemy(character, enemy)
    local tweenInfo = TweenInfo.new(
        1/tweenSpeed, -- Convert speed to time (faster speed = shorter time)
        Enum.EasingStyle.Linear,
        Enum.EasingDirection.Out,
        0,
        false,
        0
    )
    
    local targetPos = enemy.HumanoidRootPart.Position + Vector3.new(0, enemyRange, 0)
    
    local tween = TweenService:Create(
        character.HumanoidRootPart,
        tweenInfo,
        {CFrame = CFrame.new(targetPos, enemy.HumanoidRootPart.Position)}
    )
    
    tween:Play()
    return tween
end

local function toggleMobTeleport(isEnabled)
    mobTeleportActive = isEnabled
    
    if isEnabled then
        if not teleportLoop then
            teleportLoop = spawn(function()
                while mobTeleportActive do
                    pcall(function()
                        local character = game.Players.LocalPlayer.Character
                        if character and character:FindFirstChild("HumanoidRootPart") then
                            local nearestEnemy = findNearestEnemy()
                            if nearestEnemy and nearestEnemy:FindFirstChild("HumanoidRootPart") then
                                -- Calculate position at the same height but at specified range
                                local enemyPos = nearestEnemy.HumanoidRootPart.Position
                                local playerPos = character.HumanoidRootPart.Position
                                
                                -- Keep the same height as the player
                                local targetY = playerPos.Y
                                
                                -- Calculate direction vector in XZ plane
                                local direction = (enemyPos - playerPos) * Vector3.new(1, 0, 1)
                                direction = direction.Unit
                                
                                -- Calculate target position
                                local targetPos = enemyPos - (direction * enemyRange)
                                targetPos = Vector3.new(targetPos.X, targetY, targetPos.Z)
                                
                                -- Teleport after delay
                                wait(tpDelay)
                                character.HumanoidRootPart.CFrame = CFrame.new(targetPos, enemyPos)
                            end
                        end
                    end)
                    task.wait(0.1)
                end
            end)
        end
    else
        mobTeleportActive = false
        if teleportLoop then
            teleportLoop = nil
        end
    end
end

-- slider
local function createSlider(parent, position, title, min, max, defaultValue, onValueChanged)
    local sliderContainer = Instance.new("Frame")
    sliderContainer.Size = UDim2.new(0.8, 0, 0.15, 0)
    sliderContainer.Position = position
    sliderContainer.BackgroundTransparency = 1
    sliderContainer.Parent = parent

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, 0, 0.4, 0)
    titleLabel.BackgroundTransparency = 1
    titleLabel.Text = title
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.TextSize = 14
    titleLabel.Font = Enum.Font.GothamBold
    titleLabel.Parent = sliderContainer

    local sliderBar = Instance.new("Frame")
    sliderBar.Size = UDim2.new(1, 0, 0.2, 0)
    sliderBar.Position = UDim2.new(0, 0, 0.5, 0)
    sliderBar.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    sliderBar.BorderSizePixel = 0
    sliderBar.Parent = sliderContainer

    local fill = Instance.new("Frame")
    fill.Size = UDim2.new(defaultValue/(max-min), 0, 1, 0)
    fill.BackgroundColor3 = Color3.fromRGB(86, 71, 201)
    fill.BorderSizePixel = 0
    fill.Parent = sliderBar

    local valueLabel = Instance.new("TextLabel")
    valueLabel.Size = UDim2.new(1, 0, 0.4, 0)
    valueLabel.Position = UDim2.new(0, 0, 0.8, 0)
    valueLabel.BackgroundTransparency = 1
    valueLabel.Text = tostring(defaultValue)
    valueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    valueLabel.TextSize = 14
    valueLabel.Font = Enum.Font.GothamBold
    valueLabel.Parent = sliderContainer

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0.5, 0)
    corner.Parent = sliderBar

    local fillCorner = Instance.new("UICorner")
    fillCorner.CornerRadius = UDim.new(0.5, 0)
    fillCorner.Parent = fill

    local dragging = false
    
    local function updateValue(input)
        local pos = input.Position.X
        local relativePos = (pos - sliderBar.AbsolutePosition.X) / sliderBar.AbsoluteSize.X
        relativePos = math.clamp(relativePos, 0, 1)
        
        local value = math.floor(min + ((max - min) * relativePos))
        value = math.clamp(value, min, max)
        
        fill.Size = UDim2.new(relativePos, 0, 1, 0)
        valueLabel.Text = tostring(value)
        onValueChanged(value)
    end

    sliderBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            updateValue(input)
        end
    end)

    sliderBar.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)

    game:GetService("UserInputService").InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            updateValue(input)
        end
    end)

    return sliderContainer
end

local function createToggleButton(number, name, onClick)
    local button = Instance.new("TextButton")
    button.Size = UDim2.new(1, 0, 1, 0)
    button.BackgroundTransparency = 0.1
    button.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    button.Text = name
    button.TextColor3 = Color3.fromRGB(0, 0, 0)
    button.Font = Enum.Font.GothamBlack
    button.TextSize = 14
    button.LayoutOrder = number
    button.Parent = ButtonContainer
    button.ZIndex = 2
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0.3, 0)
    corner.Parent = button
    
    local stroke = Instance.new("UIStroke")
    stroke.Color = Color3.fromRGB(255, 255, 255)
    stroke.Transparency = 0.9
    stroke.Thickness = 1
    stroke.Parent = button
    
    local isEnabled = savedSettings[name] or false
    
    local function updateButtonAppearance()
        if isEnabled then
            button.BackgroundColor3 = Color3.fromRGB(86, 71, 201)
            button.TextColor3 = Color3.fromRGB(255, 255, 255)
            stroke.Transparency = 0.7
        else
            button.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            button.TextColor3 = Color3.fromRGB(0, 0, 0)
            stroke.Transparency = 0.9
        end
    end
    
    updateButtonAppearance()
    
    if isEnabled then
        onClick(true)
    end
    
    button.MouseButton1Click:Connect(function()
        isEnabled = not isEnabled
        updateButtonAppearance()
        onClick(isEnabled)
        savedSettings[name] = isEnabled
        saveSettings(savedSettings)
    end)
end

local function createGui()
    if gui then 
        gui:Destroy() 
    end
    
    local ScreenGui = Instance.new("ScreenGui")
    local MainFrame = Instance.new("Frame")
    local ImageLabel = Instance.new("ImageLabel")
    local CloseButton = Instance.new("TextButton")
    local ButtonContainer = Instance.new("Frame")
    local HeaderLabel = Instance.new("TextLabel")
    
    ScreenGui.Name = "PersistentGUI"
    ScreenGui.ResetOnSpawn = false
    ScreenGui.DisplayOrder = 999999999
    ScreenGui.Parent = game.Players.LocalPlayer.PlayerGui
    
    CloseButton.Size = UDim2.new(0, 150, 0, 45)
    CloseButton.Position = UDim2.new(0.5, -75, 0, -40)
    CloseButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    CloseButton.BackgroundTransparency = 0.3
    CloseButton.Text = "Open/Close"
    CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    CloseButton.Font = Enum.Font.GothamBlack
    CloseButton.TextSize = 16
    CloseButton.Parent = ScreenGui
    CloseButton.ZIndex = 10
    
    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(0.3, 0)
    closeCorner.Parent = CloseButton
    
    local closeStroke = Instance.new("UIStroke")
    closeStroke.Color = Color3.fromRGB(255, 255, 255)
    closeStroke.Transparency = 0.8
    closeStroke.Thickness = 1
    closeStroke.Parent = CloseButton
    
    MainFrame.Size = UDim2.new(0.25, 0, 0.7, 0)
    MainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
    MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
    MainFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    MainFrame.BackgroundTransparency = 0.5
    MainFrame.BorderSizePixel = 0
    MainFrame.ClipsDescendants = true
    MainFrame.Visible = true
    MainFrame.ZIndex = 1
    MainFrame.Parent = ScreenGui
    
    local mainFrameStroke = Instance.new("UIStroke")
    mainFrameStroke.Color = Color3.fromRGB(86, 71, 201)
    mainFrameStroke.Thickness = 2
    mainFrameStroke.Parent = MainFrame
    
    ImageLabel.Size = UDim2.new(1, 0, 0.6, 0)
    ImageLabel.Position = UDim2.new(0, 0, 0, 0)
    ImageLabel.BackgroundTransparency = 1
    ImageLabel.Image = "rbxassetid://83971645462159"
    ImageLabel.ScaleType = Enum.ScaleType.Fit
    ImageLabel.ZIndex = 2
    ImageLabel.Parent = MainFrame
    
    HeaderLabel.Size = UDim2.new(1, 0, 0.1, 0)
    HeaderLabel.Position = UDim2.new(0, 0, 0, 0)
    HeaderLabel.BackgroundTransparency = 1
    HeaderLabel.Text = "Kinayo Ripoff"
    HeaderLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    HeaderLabel.Font = Enum.Font.GothamBold
    HeaderLabel.TextSize = 24
    HeaderLabel.ZIndex = 3
    HeaderLabel.Parent = MainFrame
    
    ButtonContainer.Size = UDim2.new(0.8, 0, 0.15, 0)
    ButtonContainer.Position = UDim2.new(0.5, 0, 0.45, 0)
    ButtonContainer.AnchorPoint = Vector2.new(0.5, 0.5)
    ButtonContainer.BackgroundTransparency = 1
    ButtonContainer.Parent = MainFrame

    local UIGridLayout = Instance.new("UIGridLayout")
    UIGridLayout.Parent = ButtonContainer
    UIGridLayout.CellSize = UDim2.new(0.3, 0, 0.8, 0)
    UIGridLayout.CellPadding = UDim2.new(0.05, 0, 0.1, 0)
    UIGridLayout.SortOrder = Enum.SortOrder.LayoutOrder
    UIGridLayout.FillDirection = Enum.FillDirection.Horizontal
    UIGridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    UIGridLayout.VerticalAlignment = Enum.VerticalAlignment.Center
    
    makeDraggable(CloseButton)
    makeDraggable(MainFrame)
    
    local savedSettings = loadSettings()
    
    -- Save references to the main GUI elements
    gui = ScreenGui
    mainFrame = MainFrame
    closeButton = CloseButton
    
    -- Create buttons and sliders
    createToggleButton(1, "Auto Hit", toggleAutoHit)
    createToggleButton(2, "Auto Ability", toggleAutoAbility)
    createToggleButton(3, "Mob Teleport", toggleMobTeleport)

    -- Create sliders
    createSlider(
        MainFrame, 
        UDim2.new(0.1, 0, 0.65, 0),
        "TP Delay", 
        0, 
        5, 
        savedSettings["tpDelay"] or tpDelay,
        function(value) 
            tpDelay = value 
            savedSettings["tpDelay"] = value
            saveSettings(savedSettings)
        end
    )

    createSlider(
        MainFrame, 
        UDim2.new(0.1, 0, 0.8, 0),
        "Enemy Range", 
        1, 
        15, 
        savedSettings["enemyRange"] or enemyRange,
        function(value) 
            enemyRange = value 
            savedSettings["enemyRange"] = value
            saveSettings(savedSettings)
        end
    )
    
    return ScreenGui
end

-- Initialize variables when script starts
local savedSettings = loadSettings()
tpDelay = savedSettings["tpDelay"] or 2.5
enemyRange = savedSettings["enemyRange"] or 5

-- Create the initial GUI
createGui()
